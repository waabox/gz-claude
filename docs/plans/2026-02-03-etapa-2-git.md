# Etapa 2: Git - Plan de Implementación

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implementar el módulo Git usando git2 para obtener información de repositorios (branch, dirty status, ahead/behind, staged/unstaged) con tres niveles de detalle configurables.

**Architecture:** Wrapper sobre git2 que expone una API simple para obtener GitInfo de un path. Tres niveles de detalle (minimal, standard, detailed) que determinan cuánta información se recolecta. Manejo graceful de errores (path no es repo, repo corrupto, etc.).

**Tech Stack:** git2 (libgit2 bindings), GitInfoLevel del módulo config.

---

## Task 1: Definir structs para información de Git

**Files:**
- Modify: `src/git/mod.rs`

**Step 1: Crear los structs de información Git**

```rust
//! Git repository information using git2.
//!
//! @author waabox(waabox[at]gmail[dot]com)

use std::path::Path;

/// Information about a Git repository.
#[derive(Debug, Clone, Default)]
pub struct GitInfo {
    /// Current branch name (None if detached HEAD).
    pub branch: Option<String>,
    /// Whether there are uncommitted changes.
    pub is_dirty: bool,
    /// Number of commits ahead of upstream.
    pub ahead: u32,
    /// Number of commits behind upstream.
    pub behind: u32,
    /// Number of staged files.
    pub staged_count: u32,
    /// Number of unstaged modified files.
    pub unstaged_count: u32,
    /// List of modified files (only populated for detailed level).
    pub modified_files: Vec<String>,
}

impl GitInfo {
    /// Format as minimal string: "main *" or "main".
    pub fn format_minimal(&self) -> String {
        let branch = self.branch.as_deref().unwrap_or("HEAD");
        if self.is_dirty {
            format!("{} *", branch)
        } else {
            branch.to_string()
        }
    }

    /// Format as standard string: "main * | +2 -1 | 3S 2U".
    pub fn format_standard(&self) -> String {
        let branch = self.branch.as_deref().unwrap_or("HEAD");
        let dirty = if self.is_dirty { " *" } else { "" };
        let ahead_behind = if self.ahead > 0 || self.behind > 0 {
            format!(" | +{} -{}", self.ahead, self.behind)
        } else {
            String::new()
        };
        let staged_unstaged = if self.staged_count > 0 || self.unstaged_count > 0 {
            format!(" | {}S {}U", self.staged_count, self.unstaged_count)
        } else {
            String::new()
        };
        format!("{}{}{}{}", branch, dirty, ahead_behind, staged_unstaged)
    }
}
```

**Step 2: Verificar que compila**

Run: `cargo check`
Expected: Compila sin errores

**Step 3: Commit**

```bash
git add src/git/mod.rs
git commit -m "feat(git): add GitInfo struct with formatting methods"
```

---

## Task 2: Implementar obtención de branch actual

**Files:**
- Modify: `src/git/mod.rs`

**Step 1: Agregar función para obtener branch**

Agregar al final del archivo:

```rust
use git2::Repository;
use crate::error::{GzClaudeError, Result};

/// Get the current branch name from a repository.
fn get_current_branch(repo: &Repository) -> Option<String> {
    let head = repo.head().ok()?;
    if head.is_branch() {
        head.shorthand().map(String::from)
    } else {
        // Detached HEAD
        None
    }
}

/// Open a Git repository at the given path.
/// Returns None if the path is not a Git repository.
pub fn open_repo(path: &Path) -> Option<Repository> {
    Repository::open(path).ok()
}
```

**Step 2: Verificar que compila**

Run: `cargo check`
Expected: Compila sin errores

**Step 3: Commit**

```bash
git add src/git/mod.rs
git commit -m "feat(git): add branch detection and repo opening"
```

---

## Task 3: Implementar detección de dirty status

**Files:**
- Modify: `src/git/mod.rs`

**Step 1: Agregar función para dirty status**

```rust
use git2::{Repository, StatusOptions};

/// Check if the repository has uncommitted changes.
fn is_repo_dirty(repo: &Repository) -> bool {
    let mut opts = StatusOptions::new();
    opts.include_untracked(true)
        .recurse_untracked_dirs(false);

    match repo.statuses(Some(&mut opts)) {
        Ok(statuses) => !statuses.is_empty(),
        Err(_) => false,
    }
}
```

**Step 2: Verificar que compila**

Run: `cargo check`
Expected: Compila sin errores

**Step 3: Commit**

```bash
git add src/git/mod.rs
git commit -m "feat(git): add dirty status detection"
```

---

## Task 4: Implementar conteo de ahead/behind

**Files:**
- Modify: `src/git/mod.rs`

**Step 1: Agregar función para ahead/behind**

```rust
/// Get the number of commits ahead and behind the upstream branch.
fn get_ahead_behind(repo: &Repository) -> (u32, u32) {
    let head = match repo.head() {
        Ok(h) => h,
        Err(_) => return (0, 0),
    };

    let local_oid = match head.target() {
        Some(oid) => oid,
        None => return (0, 0),
    };

    // Get the upstream branch
    let branch_name = match head.shorthand() {
        Some(name) => name,
        None => return (0, 0),
    };

    let branch = match repo.find_branch(branch_name, git2::BranchType::Local) {
        Ok(b) => b,
        Err(_) => return (0, 0),
    };

    let upstream = match branch.upstream() {
        Ok(u) => u,
        Err(_) => return (0, 0), // No upstream configured
    };

    let upstream_oid = match upstream.get().target() {
        Some(oid) => oid,
        None => return (0, 0),
    };

    match repo.graph_ahead_behind(local_oid, upstream_oid) {
        Ok((ahead, behind)) => (ahead as u32, behind as u32),
        Err(_) => (0, 0),
    }
}
```

**Step 2: Verificar que compila**

Run: `cargo check`
Expected: Compila sin errores

**Step 3: Commit**

```bash
git add src/git/mod.rs
git commit -m "feat(git): add ahead/behind commit counting"
```

---

## Task 5: Implementar conteo de staged/unstaged

**Files:**
- Modify: `src/git/mod.rs`

**Step 1: Agregar función para staged/unstaged**

```rust
use git2::{Repository, Status, StatusOptions};

/// Count staged and unstaged files.
fn count_staged_unstaged(repo: &Repository) -> (u32, u32) {
    let mut opts = StatusOptions::new();
    opts.include_untracked(true)
        .recurse_untracked_dirs(false);

    let statuses = match repo.statuses(Some(&mut opts)) {
        Ok(s) => s,
        Err(_) => return (0, 0),
    };

    let mut staged = 0u32;
    let mut unstaged = 0u32;

    for entry in statuses.iter() {
        let status = entry.status();

        // Staged changes (index)
        if status.intersects(
            Status::INDEX_NEW
                | Status::INDEX_MODIFIED
                | Status::INDEX_DELETED
                | Status::INDEX_RENAMED
                | Status::INDEX_TYPECHANGE,
        ) {
            staged += 1;
        }

        // Unstaged changes (workdir)
        if status.intersects(
            Status::WT_NEW
                | Status::WT_MODIFIED
                | Status::WT_DELETED
                | Status::WT_RENAMED
                | Status::WT_TYPECHANGE,
        ) {
            unstaged += 1;
        }
    }

    (staged, unstaged)
}
```

**Step 2: Verificar que compila**

Run: `cargo check`
Expected: Compila sin errores

**Step 3: Commit**

```bash
git add src/git/mod.rs
git commit -m "feat(git): add staged/unstaged file counting"
```

---

## Task 6: Implementar lista de archivos modificados

**Files:**
- Modify: `src/git/mod.rs`

**Step 1: Agregar función para listar archivos modificados**

```rust
/// Get list of modified files (for detailed level).
fn get_modified_files(repo: &Repository) -> Vec<String> {
    let mut opts = StatusOptions::new();
    opts.include_untracked(true)
        .recurse_untracked_dirs(false);

    let statuses = match repo.statuses(Some(&mut opts)) {
        Ok(s) => s,
        Err(_) => return Vec::new(),
    };

    statuses
        .iter()
        .filter_map(|entry| entry.path().map(String::from))
        .collect()
}
```

**Step 2: Verificar que compila**

Run: `cargo check`
Expected: Compila sin errores

**Step 3: Commit**

```bash
git add src/git/mod.rs
git commit -m "feat(git): add modified files listing"
```

---

## Task 7: Implementar función principal get_git_info

**Files:**
- Modify: `src/git/mod.rs`

**Step 1: Agregar función get_git_info con niveles**

```rust
use crate::config::GitInfoLevel;

/// Get Git information for a repository at the given path.
///
/// The amount of information collected depends on the level:
/// - Minimal: branch + dirty status
/// - Standard: + ahead/behind + staged/unstaged counts
/// - Detailed: + list of modified files
///
/// Returns None if the path is not a Git repository.
pub fn get_git_info(path: &Path, level: GitInfoLevel) -> Option<GitInfo> {
    let repo = open_repo(path)?;

    let branch = get_current_branch(&repo);
    let is_dirty = is_repo_dirty(&repo);

    // For minimal level, we're done
    if level == GitInfoLevel::Minimal {
        return Some(GitInfo {
            branch,
            is_dirty,
            ..Default::default()
        });
    }

    // Standard level adds ahead/behind and staged/unstaged
    let (ahead, behind) = get_ahead_behind(&repo);
    let (staged_count, unstaged_count) = count_staged_unstaged(&repo);

    if level == GitInfoLevel::Standard {
        return Some(GitInfo {
            branch,
            is_dirty,
            ahead,
            behind,
            staged_count,
            unstaged_count,
            modified_files: Vec::new(),
        });
    }

    // Detailed level adds modified files list
    let modified_files = get_modified_files(&repo);

    Some(GitInfo {
        branch,
        is_dirty,
        ahead,
        behind,
        staged_count,
        unstaged_count,
        modified_files,
    })
}
```

**Step 2: Verificar que compila**

Run: `cargo check`
Expected: Compila sin errores

**Step 3: Commit**

```bash
git add src/git/mod.rs
git commit -m "feat(git): add get_git_info with configurable detail levels"
```

---

## Task 8: Crear tests unitarios para el módulo Git

**Files:**
- Create: `src/git/tests.rs`
- Modify: `src/git/mod.rs`

**Step 1: Crear archivo de tests**

```rust
//! Tests for Git module.
//!
//! @author waabox(waabox[at]gmail[dot]com)

use super::*;
use std::fs;
use std::process::Command;
use tempfile::TempDir;

fn create_test_repo() -> TempDir {
    let dir = TempDir::new().unwrap();
    let path = dir.path();

    // Initialize repo
    Command::new("git")
        .args(["init"])
        .current_dir(path)
        .output()
        .unwrap();

    // Configure git user for commits
    Command::new("git")
        .args(["config", "user.email", "test@test.com"])
        .current_dir(path)
        .output()
        .unwrap();

    Command::new("git")
        .args(["config", "user.name", "Test User"])
        .current_dir(path)
        .output()
        .unwrap();

    dir
}

fn create_file(dir: &TempDir, name: &str, content: &str) {
    fs::write(dir.path().join(name), content).unwrap();
}

fn git_add(dir: &TempDir, file: &str) {
    Command::new("git")
        .args(["add", file])
        .current_dir(dir.path())
        .output()
        .unwrap();
}

fn git_commit(dir: &TempDir, msg: &str) {
    Command::new("git")
        .args(["commit", "-m", msg])
        .current_dir(dir.path())
        .output()
        .unwrap();
}

#[test]
fn when_path_is_not_repo_should_return_none() {
    let dir = TempDir::new().unwrap();
    let info = get_git_info(dir.path(), GitInfoLevel::Minimal);
    assert!(info.is_none());
}

#[test]
fn when_repo_is_clean_should_not_be_dirty() {
    let dir = create_test_repo();
    create_file(&dir, "file.txt", "content");
    git_add(&dir, "file.txt");
    git_commit(&dir, "Initial commit");

    let info = get_git_info(dir.path(), GitInfoLevel::Minimal).unwrap();
    assert!(!info.is_dirty);
}

#[test]
fn when_repo_has_changes_should_be_dirty() {
    let dir = create_test_repo();
    create_file(&dir, "file.txt", "content");
    git_add(&dir, "file.txt");
    git_commit(&dir, "Initial commit");

    // Make a change
    create_file(&dir, "file.txt", "modified content");

    let info = get_git_info(dir.path(), GitInfoLevel::Minimal).unwrap();
    assert!(info.is_dirty);
}

#[test]
fn when_repo_has_untracked_should_be_dirty() {
    let dir = create_test_repo();
    create_file(&dir, "file.txt", "content");
    git_add(&dir, "file.txt");
    git_commit(&dir, "Initial commit");

    // Add untracked file
    create_file(&dir, "untracked.txt", "new file");

    let info = get_git_info(dir.path(), GitInfoLevel::Minimal).unwrap();
    assert!(info.is_dirty);
}

#[test]
fn when_getting_branch_should_return_current_branch() {
    let dir = create_test_repo();
    create_file(&dir, "file.txt", "content");
    git_add(&dir, "file.txt");
    git_commit(&dir, "Initial commit");

    let info = get_git_info(dir.path(), GitInfoLevel::Minimal).unwrap();
    // Default branch could be "main" or "master" depending on git config
    assert!(info.branch.is_some());
}

#[test]
fn when_standard_level_should_include_staged_count() {
    let dir = create_test_repo();
    create_file(&dir, "file.txt", "content");
    git_add(&dir, "file.txt");
    git_commit(&dir, "Initial commit");

    // Stage a new file
    create_file(&dir, "staged.txt", "staged content");
    git_add(&dir, "staged.txt");

    let info = get_git_info(dir.path(), GitInfoLevel::Standard).unwrap();
    assert_eq!(info.staged_count, 1);
}

#[test]
fn when_standard_level_should_include_unstaged_count() {
    let dir = create_test_repo();
    create_file(&dir, "file.txt", "content");
    git_add(&dir, "file.txt");
    git_commit(&dir, "Initial commit");

    // Modify without staging
    create_file(&dir, "file.txt", "modified");

    let info = get_git_info(dir.path(), GitInfoLevel::Standard).unwrap();
    assert_eq!(info.unstaged_count, 1);
}

#[test]
fn when_detailed_level_should_include_modified_files() {
    let dir = create_test_repo();
    create_file(&dir, "file.txt", "content");
    git_add(&dir, "file.txt");
    git_commit(&dir, "Initial commit");

    // Modify file
    create_file(&dir, "file.txt", "modified");

    let info = get_git_info(dir.path(), GitInfoLevel::Detailed).unwrap();
    assert!(info.modified_files.contains(&"file.txt".to_string()));
}

#[test]
fn when_formatting_minimal_dirty_should_show_asterisk() {
    let info = GitInfo {
        branch: Some("main".to_string()),
        is_dirty: true,
        ..Default::default()
    };
    assert_eq!(info.format_minimal(), "main *");
}

#[test]
fn when_formatting_minimal_clean_should_not_show_asterisk() {
    let info = GitInfo {
        branch: Some("main".to_string()),
        is_dirty: false,
        ..Default::default()
    };
    assert_eq!(info.format_minimal(), "main");
}

#[test]
fn when_formatting_standard_should_include_all_info() {
    let info = GitInfo {
        branch: Some("main".to_string()),
        is_dirty: true,
        ahead: 2,
        behind: 1,
        staged_count: 3,
        unstaged_count: 2,
        ..Default::default()
    };
    let formatted = info.format_standard();
    assert!(formatted.contains("main"));
    assert!(formatted.contains("*"));
    assert!(formatted.contains("+2"));
    assert!(formatted.contains("-1"));
    assert!(formatted.contains("3S"));
    assert!(formatted.contains("2U"));
}
```

**Step 2: Agregar módulo de tests a mod.rs**

Agregar al final de `src/git/mod.rs`:

```rust
#[cfg(test)]
mod tests;
```

**Step 3: Ejecutar tests**

Run: `cargo test git`
Expected: 12 tests pasan

**Step 4: Commit**

```bash
git add src/git/
git commit -m "test(git): add unit tests for Git module"
```

---

## Verificación Final

**Run all checks:**

```bash
cargo fmt --check
cargo clippy -- -D warnings
cargo test
cargo build --release
```

Expected: Todo pasa sin errores ni warnings.

---

## Resumen de Commits

1. `feat(git): add GitInfo struct with formatting methods`
2. `feat(git): add branch detection and repo opening`
3. `feat(git): add dirty status detection`
4. `feat(git): add ahead/behind commit counting`
5. `feat(git): add staged/unstaged file counting`
6. `feat(git): add modified files listing`
7. `feat(git): add get_git_info with configurable detail levels`
8. `test(git): add unit tests for Git module`
