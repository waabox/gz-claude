# Stage 3: TUI Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement the TUI panel with drill-down navigation between Workspaces, Projects, and File Browser views using ratatui.

**Architecture:** Three-view navigation system with state machine controlling view transitions. Each view is a separate component with its own rendering and input handling. State is managed centrally with events propagating through a message system.

**Tech Stack:** ratatui 0.30, crossterm 0.29, existing config and git modules

---

## Task 1: App State and View Enum

**Files:**
- Create: `src/tui/app.rs`
- Modify: `src/tui/mod.rs`

**Step 1: Write failing test for View enum and AppState**

Create `src/tui/app.rs`:

```rust
//! Application state management.
//!
//! @author waabox(waabox[at]gmail[dot]com)

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn when_creating_app_state_should_start_at_workspaces_view() {
        let state = AppState::new();
        assert!(matches!(state.current_view, View::Workspaces));
    }

    #[test]
    fn when_navigating_to_workspace_should_change_view_to_projects() {
        let mut state = AppState::new();
        state.navigate_to_workspace("fanki".to_string());
        assert!(matches!(state.current_view, View::Projects { .. }));
    }

    #[test]
    fn when_navigating_back_from_projects_should_return_to_workspaces() {
        let mut state = AppState::new();
        state.navigate_to_workspace("fanki".to_string());
        state.navigate_back();
        assert!(matches!(state.current_view, View::Workspaces));
    }

    #[test]
    fn when_navigating_to_project_should_change_view_to_file_browser() {
        let mut state = AppState::new();
        state.navigate_to_workspace("fanki".to_string());
        state.navigate_to_project(0);
        assert!(matches!(state.current_view, View::FileBrowser { .. }));
    }

    #[test]
    fn when_navigating_back_from_file_browser_should_return_to_projects() {
        let mut state = AppState::new();
        state.navigate_to_workspace("fanki".to_string());
        state.navigate_to_project(0);
        state.navigate_back();
        assert!(matches!(state.current_view, View::Projects { .. }));
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test tui::app --no-run 2>&1 | head -20`
Expected: Compilation error (types not defined)

**Step 3: Write minimal implementation**

Add to `src/tui/app.rs` above the tests:

```rust
/// Current view in the navigation hierarchy.
#[derive(Debug, Clone)]
pub enum View {
    /// List of workspaces
    Workspaces,
    /// List of projects in a workspace
    Projects { workspace_id: String },
    /// File browser for a project
    FileBrowser { workspace_id: String, project_index: usize },
}

/// Application state.
#[derive(Debug)]
pub struct AppState {
    pub current_view: View,
    pub selected_index: usize,
    pub should_quit: bool,
}

impl AppState {
    pub fn new() -> Self {
        Self {
            current_view: View::Workspaces,
            selected_index: 0,
            should_quit: false,
        }
    }

    pub fn navigate_to_workspace(&mut self, workspace_id: String) {
        self.current_view = View::Projects { workspace_id };
        self.selected_index = 0;
    }

    pub fn navigate_to_project(&mut self, project_index: usize) {
        if let View::Projects { workspace_id } = &self.current_view {
            self.current_view = View::FileBrowser {
                workspace_id: workspace_id.clone(),
                project_index,
            };
            self.selected_index = 0;
        }
    }

    pub fn navigate_back(&mut self) {
        match &self.current_view {
            View::Workspaces => {}
            View::Projects { .. } => {
                self.current_view = View::Workspaces;
                self.selected_index = 0;
            }
            View::FileBrowser { workspace_id, .. } => {
                self.current_view = View::Projects {
                    workspace_id: workspace_id.clone(),
                };
                self.selected_index = 0;
            }
        }
    }
}

impl Default for AppState {
    fn default() -> Self {
        Self::new()
    }
}
```

**Step 4: Update mod.rs**

Modify `src/tui/mod.rs`:

```rust
//! TUI components using ratatui.
//!
//! @author waabox(waabox[at]gmail[dot]com)

pub mod app;

pub use app::{AppState, View};
```

**Step 5: Run tests to verify they pass**

Run: `cargo test tui::app -- --test-threads=1`
Expected: 5 tests passing

**Step 6: Commit**

```bash
git add src/tui/
git commit -m "feat(tui): add AppState and View enum for navigation"
```

---

## Task 2: Terminal Setup and Event Handling

**Files:**
- Create: `src/tui/terminal.rs`
- Modify: `src/tui/mod.rs`

**Step 1: Write failing test for terminal setup**

Create `src/tui/terminal.rs`:

```rust
//! Terminal initialization and event handling.
//!
//! @author waabox(waabox[at]gmail[dot]com)

use std::io::{self, Stdout};
use crossterm::{
    event::{self, Event, KeyCode, KeyEvent, KeyModifiers},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{backend::CrosstermBackend, Terminal};

use crate::error::Result;

pub type Tui = Terminal<CrosstermBackend<Stdout>>;

/// Initialize the terminal for TUI rendering.
pub fn init() -> Result<Tui> {
    execute!(io::stdout(), EnterAlternateScreen)?;
    enable_raw_mode()?;
    let backend = CrosstermBackend::new(io::stdout());
    let terminal = Terminal::new(backend)?;
    Ok(terminal)
}

/// Restore the terminal to its original state.
pub fn restore() -> Result<()> {
    execute!(io::stdout(), LeaveAlternateScreen)?;
    disable_raw_mode()?;
    Ok(())
}

/// Input events that the app handles.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum InputEvent {
    Up,
    Down,
    Enter,
    Back,
    Quit,
    Refresh,
    Action(char),
}

/// Poll for keyboard input and convert to InputEvent.
pub fn poll_event(timeout_ms: u64) -> Result<Option<InputEvent>> {
    if event::poll(std::time::Duration::from_millis(timeout_ms))? {
        if let Event::Key(key) = event::read()? {
            return Ok(key_to_event(key));
        }
    }
    Ok(None)
}

fn key_to_event(key: KeyEvent) -> Option<InputEvent> {
    match key.code {
        KeyCode::Up | KeyCode::Char('k') => Some(InputEvent::Up),
        KeyCode::Down | KeyCode::Char('j') => Some(InputEvent::Down),
        KeyCode::Enter => Some(InputEvent::Enter),
        KeyCode::Esc | KeyCode::Backspace => Some(InputEvent::Back),
        KeyCode::Char('q') => Some(InputEvent::Quit),
        KeyCode::Char('r') => Some(InputEvent::Refresh),
        KeyCode::Char(c) if key.modifiers.is_empty() => Some(InputEvent::Action(c)),
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn when_pressing_up_or_k_should_return_up_event() {
        let up_key = KeyEvent::new(KeyCode::Up, KeyModifiers::NONE);
        let k_key = KeyEvent::new(KeyCode::Char('k'), KeyModifiers::NONE);

        assert_eq!(key_to_event(up_key), Some(InputEvent::Up));
        assert_eq!(key_to_event(k_key), Some(InputEvent::Up));
    }

    #[test]
    fn when_pressing_down_or_j_should_return_down_event() {
        let down_key = KeyEvent::new(KeyCode::Down, KeyModifiers::NONE);
        let j_key = KeyEvent::new(KeyCode::Char('j'), KeyModifiers::NONE);

        assert_eq!(key_to_event(down_key), Some(InputEvent::Down));
        assert_eq!(key_to_event(j_key), Some(InputEvent::Down));
    }

    #[test]
    fn when_pressing_enter_should_return_enter_event() {
        let key = KeyEvent::new(KeyCode::Enter, KeyModifiers::NONE);
        assert_eq!(key_to_event(key), Some(InputEvent::Enter));
    }

    #[test]
    fn when_pressing_esc_or_backspace_should_return_back_event() {
        let esc_key = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let backspace_key = KeyEvent::new(KeyCode::Backspace, KeyModifiers::NONE);

        assert_eq!(key_to_event(esc_key), Some(InputEvent::Back));
        assert_eq!(key_to_event(backspace_key), Some(InputEvent::Back));
    }

    #[test]
    fn when_pressing_q_should_return_quit_event() {
        let key = KeyEvent::new(KeyCode::Char('q'), KeyModifiers::NONE);
        assert_eq!(key_to_event(key), Some(InputEvent::Quit));
    }

    #[test]
    fn when_pressing_r_should_return_refresh_event() {
        let key = KeyEvent::new(KeyCode::Char('r'), KeyModifiers::NONE);
        assert_eq!(key_to_event(key), Some(InputEvent::Refresh));
    }

    #[test]
    fn when_pressing_other_char_should_return_action_event() {
        let key = KeyEvent::new(KeyCode::Char('c'), KeyModifiers::NONE);
        assert_eq!(key_to_event(key), Some(InputEvent::Action('c')));
    }
}
```

**Step 2: Run test to verify compilation**

Run: `cargo test tui::terminal --no-run 2>&1 | head -20`
Expected: Should compile

**Step 3: Update mod.rs**

Modify `src/tui/mod.rs`:

```rust
//! TUI components using ratatui.
//!
//! @author waabox(waabox[at]gmail[dot]com)

pub mod app;
pub mod terminal;

pub use app::{AppState, View};
pub use terminal::{init, restore, poll_event, InputEvent, Tui};
```

**Step 4: Run tests to verify they pass**

Run: `cargo test tui::terminal -- --test-threads=1`
Expected: 7 tests passing

**Step 5: Commit**

```bash
git add src/tui/
git commit -m "feat(tui): add terminal setup and event handling"
```

---

## Task 3: Workspaces View Component

**Files:**
- Create: `src/tui/views/mod.rs`
- Create: `src/tui/views/workspaces.rs`
- Modify: `src/tui/mod.rs`

**Step 1: Write failing test for workspaces view**

Create `src/tui/views/mod.rs`:

```rust
//! TUI view components.
//!
//! @author waabox(waabox[at]gmail[dot]com)

pub mod workspaces;

pub use workspaces::WorkspacesView;
```

Create `src/tui/views/workspaces.rs`:

```rust
//! Workspaces list view.
//!
//! @author waabox(waabox[at]gmail[dot]com)

use ratatui::{
    layout::{Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, List, ListItem, ListState, Paragraph},
    Frame,
};

use crate::config::Config;

/// Workspaces view component.
pub struct WorkspacesView<'a> {
    config: &'a Config,
    selected: usize,
}

impl<'a> WorkspacesView<'a> {
    pub fn new(config: &'a Config, selected: usize) -> Self {
        Self { config, selected }
    }

    /// Get sorted workspace IDs.
    pub fn workspace_ids(&self) -> Vec<&str> {
        let mut ids: Vec<&str> = self.config.workspace.keys().map(|s| s.as_str()).collect();
        ids.sort();
        ids
    }

    /// Render the workspaces list.
    pub fn render(&self, frame: &mut Frame, area: Rect) {
        let chunks = Layout::default()
            .direction(Direction::Vertical)
            .constraints([
                Constraint::Length(3), // Title
                Constraint::Min(1),    // List
                Constraint::Length(3), // Help
            ])
            .split(area);

        // Title
        let title = Paragraph::new("Workspaces")
            .style(Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD))
            .block(Block::default().borders(Borders::BOTTOM));
        frame.render_widget(title, chunks[0]);

        // Workspace list
        let workspace_ids = self.workspace_ids();
        let items: Vec<ListItem> = workspace_ids
            .iter()
            .enumerate()
            .map(|(i, id)| {
                let workspace = self.config.workspace.get(*id).unwrap();
                let style = if i == self.selected {
                    Style::default()
                        .fg(Color::Yellow)
                        .add_modifier(Modifier::BOLD)
                };
                let prefix = if i == self.selected { "> " } else { "  " };
                ListItem::new(Line::from(vec![
                    Span::raw(prefix),
                    Span::styled(&workspace.name, style),
                ]))
            })
            .collect();

        let list = List::new(items)
            .block(Block::default().borders(Borders::NONE));
        frame.render_widget(list, chunks[1]);

        // Help bar
        let help = Paragraph::new("Enter: select  q: quit")
            .style(Style::default().fg(Color::DarkGray))
            .block(Block::default().borders(Borders::TOP));
        frame.render_widget(help, chunks[2]);
    }

    /// Get the number of workspaces.
    pub fn len(&self) -> usize {
        self.config.workspace.len()
    }

    /// Check if there are no workspaces.
    pub fn is_empty(&self) -> bool {
        self.config.workspace.is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    use crate::config::{GlobalConfig, Workspace};

    fn create_test_config() -> Config {
        let mut workspaces = HashMap::new();
        workspaces.insert(
            "fanki".to_string(),
            Workspace {
                name: "Fanki".to_string(),
                actions: HashMap::new(),
                projects: vec![],
            },
        );
        workspaces.insert(
            "helios".to_string(),
            Workspace {
                name: "Helios".to_string(),
                actions: HashMap::new(),
                projects: vec![],
            },
        );

        Config {
            global: GlobalConfig {
                editor: "$EDITOR".to_string(),
                git_info_level: Default::default(),
                actions: HashMap::new(),
            },
            web_client: Default::default(),
            workspace: workspaces,
        }
    }

    #[test]
    fn when_creating_view_should_return_sorted_workspace_ids() {
        let config = create_test_config();
        let view = WorkspacesView::new(&config, 0);
        let ids = view.workspace_ids();
        assert_eq!(ids, vec!["fanki", "helios"]);
    }

    #[test]
    fn when_getting_len_should_return_workspace_count() {
        let config = create_test_config();
        let view = WorkspacesView::new(&config, 0);
        assert_eq!(view.len(), 2);
    }

    #[test]
    fn when_config_has_no_workspaces_should_return_empty() {
        let config = Config {
            global: GlobalConfig {
                editor: "$EDITOR".to_string(),
                git_info_level: Default::default(),
                actions: HashMap::new(),
            },
            web_client: Default::default(),
            workspace: HashMap::new(),
        };
        let view = WorkspacesView::new(&config, 0);
        assert!(view.is_empty());
    }
}
```

**Step 2: Run test to verify compilation**

Run: `cargo test tui::views::workspaces --no-run 2>&1 | head -30`
Expected: Should compile

**Step 3: Update tui/mod.rs**

```rust
//! TUI components using ratatui.
//!
//! @author waabox(waabox[at]gmail[dot]com)

pub mod app;
pub mod terminal;
pub mod views;

pub use app::{AppState, View};
pub use terminal::{init, restore, poll_event, InputEvent, Tui};
```

**Step 4: Run tests to verify they pass**

Run: `cargo test tui::views::workspaces -- --test-threads=1`
Expected: 3 tests passing

**Step 5: Commit**

```bash
git add src/tui/
git commit -m "feat(tui): add WorkspacesView component"
```

---

## Task 4: Projects View Component

**Files:**
- Create: `src/tui/views/projects.rs`
- Modify: `src/tui/views/mod.rs`

**Step 1: Write failing test for projects view**

Create `src/tui/views/projects.rs`:

```rust
//! Projects list view with git info and actions.
//!
//! @author waabox(waabox[at]gmail[dot]com)

use ratatui::{
    layout::{Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, List, ListItem, Paragraph},
    Frame,
};

use crate::config::{Action, Config, GitInfoLevel, Workspace};
use crate::git::{get_git_info, GitInfo};

/// Projects view component.
pub struct ProjectsView<'a> {
    config: &'a Config,
    workspace_id: &'a str,
    selected: usize,
    git_info_cache: Vec<Option<GitInfo>>,
}

impl<'a> ProjectsView<'a> {
    pub fn new(config: &'a Config, workspace_id: &'a str, selected: usize) -> Self {
        let git_info_cache = Self::load_git_info(config, workspace_id);
        Self {
            config,
            workspace_id,
            selected,
            git_info_cache,
        }
    }

    fn load_git_info(config: &Config, workspace_id: &str) -> Vec<Option<GitInfo>> {
        config
            .workspace
            .get(workspace_id)
            .map(|ws| {
                ws.projects
                    .iter()
                    .map(|p| get_git_info(&p.path, config.global.git_info_level))
                    .collect()
            })
            .unwrap_or_default()
    }

    /// Refresh git info for all projects.
    pub fn refresh_git_info(&mut self) {
        self.git_info_cache = Self::load_git_info(self.config, self.workspace_id);
    }

    /// Get the workspace.
    pub fn workspace(&self) -> Option<&Workspace> {
        self.config.workspace.get(self.workspace_id)
    }

    /// Get resolved actions for the selected project.
    pub fn resolved_actions(&self) -> Vec<(String, Action)> {
        let actions = self.config.resolve_actions(self.workspace_id, self.selected);
        let mut sorted: Vec<_> = actions.into_iter().collect();
        sorted.sort_by(|a, b| a.0.cmp(&b.0));
        sorted
    }

    /// Get the number of projects.
    pub fn len(&self) -> usize {
        self.workspace().map(|ws| ws.projects.len()).unwrap_or(0)
    }

    /// Check if there are no projects.
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Render the projects list.
    pub fn render(&self, frame: &mut Frame, area: Rect) {
        let Some(workspace) = self.workspace() else {
            return;
        };

        let chunks = Layout::default()
            .direction(Direction::Vertical)
            .constraints([
                Constraint::Length(3), // Title
                Constraint::Min(1),    // List
                Constraint::Length(3), // Help
            ])
            .split(area);

        // Title
        let title = Paragraph::new(format!("{} - Projects", workspace.name))
            .style(Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD))
            .block(Block::default().borders(Borders::BOTTOM));
        frame.render_widget(title, chunks[0]);

        // Project list
        let items: Vec<ListItem> = workspace
            .projects
            .iter()
            .enumerate()
            .map(|(i, project)| {
                let style = if i == self.selected {
                    Style::default()
                        .fg(Color::Yellow)
                        .add_modifier(Modifier::BOLD)
                } else {
                    Style::default()
                };

                let prefix = if i == self.selected { "> " } else { "  " };

                // Git info
                let git_str = self
                    .git_info_cache
                    .get(i)
                    .and_then(|opt| opt.as_ref())
                    .map(|info| format!("  {}", info.format_minimal()))
                    .unwrap_or_default();

                // Action icons
                let actions = self.config.resolve_actions(self.workspace_id, i);
                let icons: String = actions
                    .values()
                    .filter_map(|a| a.icon.as_ref())
                    .map(|s| s.as_str())
                    .collect::<Vec<_>>()
                    .join(" ");

                ListItem::new(Line::from(vec![
                    Span::raw(prefix),
                    Span::styled(&project.name, style),
                    Span::styled(git_str, Style::default().fg(Color::DarkGray)),
                    Span::raw("  "),
                    Span::raw(icons),
                ]))
            })
            .collect();

        let list = List::new(items).block(Block::default().borders(Borders::NONE));
        frame.render_widget(list, chunks[1]);

        // Help bar with actions
        let actions = self.resolved_actions();
        let action_help: String = actions
            .iter()
            .map(|(key, action)| {
                let icon = action.icon.as_deref().unwrap_or("");
                format!("{}{}:{}", icon, key, action.name)
            })
            .collect::<Vec<_>>()
            .join("  ");

        let help = Paragraph::new(format!("Enter: browse  {}  Esc: back", action_help))
            .style(Style::default().fg(Color::DarkGray))
            .block(Block::default().borders(Borders::TOP));
        frame.render_widget(help, chunks[2]);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    use std::path::PathBuf;
    use crate::config::{GlobalConfig, Project};

    fn create_test_config() -> Config {
        let mut workspaces = HashMap::new();
        let mut global_actions = HashMap::new();
        global_actions.insert(
            "c".to_string(),
            Action {
                name: "Claude".to_string(),
                command: "claude".to_string(),
                icon: Some("C".to_string()),
            },
        );

        workspaces.insert(
            "fanki".to_string(),
            Workspace {
                name: "Fanki".to_string(),
                actions: HashMap::new(),
                projects: vec![
                    Project {
                        name: "API".to_string(),
                        path: PathBuf::from("/tmp"),
                        actions: HashMap::new(),
                    },
                    Project {
                        name: "Web".to_string(),
                        path: PathBuf::from("/tmp"),
                        actions: HashMap::new(),
                    },
                ],
            },
        );

        Config {
            global: GlobalConfig {
                editor: "$EDITOR".to_string(),
                git_info_level: GitInfoLevel::Minimal,
                actions: global_actions,
            },
            web_client: Default::default(),
            workspace: workspaces,
        }
    }

    #[test]
    fn when_creating_view_should_have_correct_project_count() {
        let config = create_test_config();
        let view = ProjectsView::new(&config, "fanki", 0);
        assert_eq!(view.len(), 2);
    }

    #[test]
    fn when_getting_resolved_actions_should_include_global_actions() {
        let config = create_test_config();
        let view = ProjectsView::new(&config, "fanki", 0);
        let actions = view.resolved_actions();
        assert!(actions.iter().any(|(k, _)| k == "c"));
    }

    #[test]
    fn when_workspace_not_found_should_return_empty() {
        let config = create_test_config();
        let view = ProjectsView::new(&config, "nonexistent", 0);
        assert!(view.is_empty());
    }
}
```

**Step 2: Run test to verify compilation**

Run: `cargo test tui::views::projects --no-run 2>&1 | head -30`
Expected: Should compile

**Step 3: Update views/mod.rs**

```rust
//! TUI view components.
//!
//! @author waabox(waabox[at]gmail[dot]com)

pub mod projects;
pub mod workspaces;

pub use projects::ProjectsView;
pub use workspaces::WorkspacesView;
```

**Step 4: Run tests to verify they pass**

Run: `cargo test tui::views::projects -- --test-threads=1`
Expected: 3 tests passing

**Step 5: Commit**

```bash
git add src/tui/
git commit -m "feat(tui): add ProjectsView component with git info"
```

---

## Task 5: File Tree Model

**Files:**
- Create: `src/tui/file_tree.rs`
- Modify: `src/tui/mod.rs`

**Step 1: Write failing test for file tree**

Create `src/tui/file_tree.rs`:

```rust
//! File tree model for navigation.
//!
//! @author waabox(waabox[at]gmail[dot]com)

use std::fs;
use std::path::{Path, PathBuf};

/// A node in the file tree.
#[derive(Debug, Clone)]
pub struct FileNode {
    pub name: String,
    pub path: PathBuf,
    pub is_dir: bool,
    pub expanded: bool,
    pub depth: usize,
    pub children: Vec<FileNode>,
}

impl FileNode {
    /// Create a new file node from a path.
    pub fn new(path: &Path, depth: usize) -> Option<Self> {
        let name = path.file_name()?.to_string_lossy().to_string();
        let is_dir = path.is_dir();

        Some(Self {
            name,
            path: path.to_path_buf(),
            is_dir,
            expanded: false,
            depth,
            children: Vec::new(),
        })
    }

    /// Load children of a directory node.
    pub fn load_children(&mut self) {
        if !self.is_dir || !self.children.is_empty() {
            return;
        }

        if let Ok(entries) = fs::read_dir(&self.path) {
            let mut children: Vec<FileNode> = entries
                .filter_map(|e| e.ok())
                .filter(|e| {
                    // Skip hidden files
                    !e.file_name().to_string_lossy().starts_with('.')
                })
                .filter_map(|e| FileNode::new(&e.path(), self.depth + 1))
                .collect();

            // Sort: directories first, then alphabetically
            children.sort_by(|a, b| {
                match (a.is_dir, b.is_dir) {
                    (true, false) => std::cmp::Ordering::Less,
                    (false, true) => std::cmp::Ordering::Greater,
                    _ => a.name.to_lowercase().cmp(&b.name.to_lowercase()),
                }
            });

            self.children = children;
        }
    }

    /// Toggle expanded state for directories.
    pub fn toggle_expanded(&mut self) {
        if self.is_dir {
            self.expanded = !self.expanded;
            if self.expanded {
                self.load_children();
            }
        }
    }
}

/// File tree for a project root.
#[derive(Debug)]
pub struct FileTree {
    pub root: FileNode,
    pub flat_list: Vec<usize>, // Indices into a flattened view
}

impl FileTree {
    /// Create a new file tree from a root path.
    pub fn new(root_path: &Path) -> Option<Self> {
        let mut root = FileNode::new(root_path, 0)?;
        root.expanded = true;
        root.load_children();

        let mut tree = Self {
            root,
            flat_list: Vec::new(),
        };
        tree.rebuild_flat_list();
        Some(tree)
    }

    /// Rebuild the flattened list of visible nodes.
    fn rebuild_flat_list(&mut self) {
        self.flat_list.clear();
        self.flatten_node(&self.root.clone(), &mut 0);
    }

    fn flatten_node(&mut self, node: &FileNode, index: &mut usize) {
        self.flat_list.push(*index);
        *index += 1;

        if node.expanded {
            for child in &node.children {
                self.flatten_node(child, index);
            }
        }
    }

    /// Get the number of visible items.
    pub fn visible_count(&self) -> usize {
        self.count_visible(&self.root)
    }

    fn count_visible(&self, node: &FileNode) -> usize {
        let mut count = 1;
        if node.expanded {
            for child in &node.children {
                count += self.count_visible(child);
            }
        }
        count
    }

    /// Get a visible node by index.
    pub fn get_visible_node(&self, index: usize) -> Option<&FileNode> {
        self.get_visible_node_recursive(&self.root, index, &mut 0)
    }

    fn get_visible_node_recursive<'a>(
        &self,
        node: &'a FileNode,
        target: usize,
        current: &mut usize,
    ) -> Option<&'a FileNode> {
        if *current == target {
            return Some(node);
        }
        *current += 1;

        if node.expanded {
            for child in &node.children {
                if let Some(found) = self.get_visible_node_recursive(child, target, current) {
                    return Some(found);
                }
            }
        }
        None
    }

    /// Toggle expand/collapse at an index.
    pub fn toggle_at(&mut self, index: usize) {
        if let Some(path) = self.get_visible_node(index).map(|n| n.path.clone()) {
            self.toggle_at_path(&self.root.path.clone(), &path);
            self.rebuild_flat_list();
        }
    }

    fn toggle_at_path(&mut self, current_path: &Path, target_path: &Path) -> bool {
        if current_path == target_path {
            // Found the node, toggle it in root
            self.toggle_node_at_path(&mut self.root, target_path);
            return true;
        }
        false
    }

    fn toggle_node_at_path(&mut self, node: &mut FileNode, target_path: &Path) -> bool {
        if node.path == target_path {
            node.toggle_expanded();
            return true;
        }

        if node.expanded {
            for child in &mut node.children {
                if self.toggle_node_at_path(child, target_path) {
                    return true;
                }
            }
        }
        false
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    use std::fs::File;

    fn setup_test_dir() -> TempDir {
        let dir = TempDir::new().unwrap();
        let root = dir.path();

        // Create structure:
        // root/
        //   src/
        //     main.rs
        //   README.md
        fs::create_dir(root.join("src")).unwrap();
        File::create(root.join("src/main.rs")).unwrap();
        File::create(root.join("README.md")).unwrap();

        dir
    }

    #[test]
    fn when_creating_file_tree_should_load_root_children() {
        let dir = setup_test_dir();
        let tree = FileTree::new(dir.path()).unwrap();

        assert!(tree.root.expanded);
        assert!(!tree.root.children.is_empty());
    }

    #[test]
    fn when_getting_visible_count_should_include_expanded_nodes() {
        let dir = setup_test_dir();
        let tree = FileTree::new(dir.path()).unwrap();

        // Root + src/ + README.md = 3 (src is collapsed by default)
        assert!(tree.visible_count() >= 3);
    }

    #[test]
    fn when_getting_visible_node_should_return_correct_node() {
        let dir = setup_test_dir();
        let tree = FileTree::new(dir.path()).unwrap();

        let root_node = tree.get_visible_node(0).unwrap();
        assert_eq!(root_node.path, dir.path());
    }

    #[test]
    fn when_sorting_children_should_put_directories_first() {
        let dir = setup_test_dir();
        let tree = FileTree::new(dir.path()).unwrap();

        // First child should be src/ (directory)
        if let Some(first_child) = tree.root.children.first() {
            assert!(first_child.is_dir);
            assert_eq!(first_child.name, "src");
        }
    }
}
```

**Step 2: Run test to verify compilation**

Run: `cargo test tui::file_tree --no-run 2>&1 | head -30`
Expected: Should compile

**Step 3: Update tui/mod.rs**

```rust
//! TUI components using ratatui.
//!
//! @author waabox(waabox[at]gmail[dot]com)

pub mod app;
pub mod file_tree;
pub mod terminal;
pub mod views;

pub use app::{AppState, View};
pub use file_tree::FileTree;
pub use terminal::{init, restore, poll_event, InputEvent, Tui};
```

**Step 4: Run tests to verify they pass**

Run: `cargo test tui::file_tree -- --test-threads=1`
Expected: 4 tests passing

**Step 5: Commit**

```bash
git add src/tui/
git commit -m "feat(tui): add FileTree model for file browser"
```

---

## Task 6: File Browser View Component

**Files:**
- Create: `src/tui/views/file_browser.rs`
- Modify: `src/tui/views/mod.rs`

**Step 1: Write file browser view**

Create `src/tui/views/file_browser.rs`:

```rust
//! File browser view with tree navigation.
//!
//! @author waabox(waabox[at]gmail[dot]com)

use ratatui::{
    layout::{Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, List, ListItem, Paragraph},
    Frame,
};

use crate::config::{Action, Config, Project};
use crate::git::{get_git_info, GitInfo};
use crate::tui::file_tree::FileTree;

/// File browser view component.
pub struct FileBrowserView<'a> {
    config: &'a Config,
    workspace_id: &'a str,
    project_index: usize,
    selected: usize,
    file_tree: Option<FileTree>,
    git_info: Option<GitInfo>,
}

impl<'a> FileBrowserView<'a> {
    pub fn new(
        config: &'a Config,
        workspace_id: &'a str,
        project_index: usize,
        selected: usize,
    ) -> Self {
        let project = config
            .workspace
            .get(workspace_id)
            .and_then(|ws| ws.projects.get(project_index));

        let file_tree = project.and_then(|p| FileTree::new(&p.path));
        let git_info = project.and_then(|p| get_git_info(&p.path, config.global.git_info_level));

        Self {
            config,
            workspace_id,
            project_index,
            selected,
            file_tree,
            git_info,
        }
    }

    /// Get the project.
    pub fn project(&self) -> Option<&Project> {
        self.config
            .workspace
            .get(self.workspace_id)
            .and_then(|ws| ws.projects.get(self.project_index))
    }

    /// Get resolved actions.
    pub fn resolved_actions(&self) -> Vec<(String, Action)> {
        let actions = self
            .config
            .resolve_actions(self.workspace_id, self.project_index);
        let mut sorted: Vec<_> = actions.into_iter().collect();
        sorted.sort_by(|a, b| a.0.cmp(&b.0));
        sorted
    }

    /// Get the number of visible items.
    pub fn visible_count(&self) -> usize {
        self.file_tree
            .as_ref()
            .map(|t| t.visible_count())
            .unwrap_or(0)
    }

    /// Toggle expand/collapse at current selection.
    pub fn toggle_selected(&mut self) {
        if let Some(tree) = &mut self.file_tree {
            tree.toggle_at(self.selected);
        }
    }

    /// Check if selected item is a file.
    pub fn selected_is_file(&self) -> bool {
        self.file_tree
            .as_ref()
            .and_then(|t| t.get_visible_node(self.selected))
            .map(|n| !n.is_dir)
            .unwrap_or(false)
    }

    /// Get the path of the selected item.
    pub fn selected_path(&self) -> Option<std::path::PathBuf> {
        self.file_tree
            .as_ref()
            .and_then(|t| t.get_visible_node(self.selected))
            .map(|n| n.path.clone())
    }

    /// Refresh git info.
    pub fn refresh_git_info(&mut self) {
        if let Some(project) = self.project() {
            self.git_info = get_git_info(&project.path, self.config.global.git_info_level);
        }
    }

    /// Render the file browser.
    pub fn render(&self, frame: &mut Frame, area: Rect) {
        let Some(project) = self.project() else {
            return;
        };

        let chunks = Layout::default()
            .direction(Direction::Vertical)
            .constraints([
                Constraint::Length(3), // Title + git info
                Constraint::Min(1),    // File tree
                Constraint::Length(3), // Help
            ])
            .split(area);

        // Title with git info
        let git_str = self
            .git_info
            .as_ref()
            .map(|i| i.format_standard())
            .unwrap_or_default();

        let title = Paragraph::new(Line::from(vec![
            Span::styled(
                &project.name,
                Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD),
            ),
            Span::raw("  "),
            Span::styled(git_str, Style::default().fg(Color::DarkGray)),
        ]))
        .block(Block::default().borders(Borders::BOTTOM));
        frame.render_widget(title, chunks[0]);

        // File tree
        if let Some(tree) = &self.file_tree {
            let items: Vec<ListItem> = (0..tree.visible_count())
                .filter_map(|i| {
                    let node = tree.get_visible_node(i)?;
                    let style = if i == self.selected {
                        Style::default()
                            .fg(Color::Yellow)
                            .add_modifier(Modifier::BOLD)
                    } else {
                        Style::default()
                    };

                    let indent = "  ".repeat(node.depth);
                    let prefix = if i == self.selected { "> " } else { "  " };
                    let icon = if node.is_dir {
                        if node.expanded { "v " } else { "> " }
                    } else {
                        "  "
                    };

                    Some(ListItem::new(Line::from(vec![
                        Span::raw(prefix),
                        Span::raw(indent),
                        Span::raw(icon),
                        Span::styled(&node.name, style),
                    ])))
                })
                .collect();

            let list = List::new(items).block(Block::default().borders(Borders::NONE));
            frame.render_widget(list, chunks[1]);
        }

        // Help bar with actions
        let actions = self.resolved_actions();
        let action_help: String = actions
            .iter()
            .map(|(key, action)| {
                let icon = action.icon.as_deref().unwrap_or("");
                format!("{}{}:{}", icon, key, action.name)
            })
            .collect::<Vec<_>>()
            .join("  ");

        let help = Paragraph::new(format!("{}  Enter: open/expand  Esc: back", action_help))
            .style(Style::default().fg(Color::DarkGray))
            .block(Block::default().borders(Borders::TOP));
        frame.render_widget(help, chunks[2]);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    use std::path::PathBuf;
    use tempfile::TempDir;
    use std::fs;
    use crate::config::{GlobalConfig, Workspace};

    fn setup_test_dir() -> TempDir {
        let dir = TempDir::new().unwrap();
        fs::create_dir(dir.path().join("src")).unwrap();
        fs::File::create(dir.path().join("src/main.rs")).unwrap();
        fs::File::create(dir.path().join("README.md")).unwrap();
        dir
    }

    fn create_test_config(path: PathBuf) -> Config {
        let mut workspaces = HashMap::new();
        workspaces.insert(
            "test".to_string(),
            Workspace {
                name: "Test".to_string(),
                actions: HashMap::new(),
                projects: vec![crate::config::Project {
                    name: "TestProject".to_string(),
                    path,
                    actions: HashMap::new(),
                }],
            },
        );

        Config {
            global: GlobalConfig {
                editor: "$EDITOR".to_string(),
                git_info_level: Default::default(),
                actions: HashMap::new(),
            },
            web_client: Default::default(),
            workspace: workspaces,
        }
    }

    #[test]
    fn when_creating_view_should_load_file_tree() {
        let dir = setup_test_dir();
        let config = create_test_config(dir.path().to_path_buf());
        let view = FileBrowserView::new(&config, "test", 0, 0);

        assert!(view.file_tree.is_some());
        assert!(view.visible_count() > 0);
    }

    #[test]
    fn when_getting_project_should_return_correct_project() {
        let dir = setup_test_dir();
        let config = create_test_config(dir.path().to_path_buf());
        let view = FileBrowserView::new(&config, "test", 0, 0);

        let project = view.project().unwrap();
        assert_eq!(project.name, "TestProject");
    }
}
```

**Step 2: Run test to verify compilation**

Run: `cargo test tui::views::file_browser --no-run 2>&1 | head -30`
Expected: Should compile

**Step 3: Update views/mod.rs**

```rust
//! TUI view components.
//!
//! @author waabox(waabox[at]gmail[dot]com)

pub mod file_browser;
pub mod projects;
pub mod workspaces;

pub use file_browser::FileBrowserView;
pub use projects::ProjectsView;
pub use workspaces::WorkspacesView;
```

**Step 4: Run tests to verify they pass**

Run: `cargo test tui::views::file_browser -- --test-threads=1`
Expected: 2 tests passing

**Step 5: Commit**

```bash
git add src/tui/
git commit -m "feat(tui): add FileBrowserView component"
```

---

## Task 7: Main TUI Runner

**Files:**
- Create: `src/tui/runner.rs`
- Modify: `src/tui/mod.rs`
- Modify: `src/main.rs`

**Step 1: Write the TUI runner**

Create `src/tui/runner.rs`:

```rust
//! TUI main loop runner.
//!
//! @author waabox(waabox[at]gmail[dot]com)

use ratatui::layout::Rect;

use crate::config::Config;
use crate::error::Result;
use crate::tui::app::{AppState, View};
use crate::tui::terminal::{init, poll_event, restore, InputEvent};
use crate::tui::views::{FileBrowserView, ProjectsView, WorkspacesView};

/// Run the TUI application.
pub fn run(config: &Config) -> Result<()> {
    let mut terminal = init()?;
    let mut state = AppState::new();

    let result = run_loop(&mut terminal, &mut state, config);

    restore()?;
    result
}

fn run_loop(
    terminal: &mut crate::tui::terminal::Tui,
    state: &mut AppState,
    config: &Config,
) -> Result<()> {
    loop {
        // Render
        terminal.draw(|frame| {
            let area = frame.area();
            render_current_view(frame, area, state, config);
        })?;

        // Handle input
        if let Some(event) = poll_event(100)? {
            handle_input(state, config, event);
        }

        if state.should_quit {
            break;
        }
    }

    Ok(())
}

fn render_current_view(
    frame: &mut ratatui::Frame,
    area: Rect,
    state: &AppState,
    config: &Config,
) {
    match &state.current_view {
        View::Workspaces => {
            let view = WorkspacesView::new(config, state.selected_index);
            view.render(frame, area);
        }
        View::Projects { workspace_id } => {
            let view = ProjectsView::new(config, workspace_id, state.selected_index);
            view.render(frame, area);
        }
        View::FileBrowser {
            workspace_id,
            project_index,
        } => {
            let view = FileBrowserView::new(
                config,
                workspace_id,
                *project_index,
                state.selected_index,
            );
            view.render(frame, area);
        }
    }
}

fn handle_input(state: &mut AppState, config: &Config, event: InputEvent) {
    match event {
        InputEvent::Up => {
            if state.selected_index > 0 {
                state.selected_index -= 1;
            }
        }
        InputEvent::Down => {
            let max = get_max_index(state, config);
            if state.selected_index < max.saturating_sub(1) {
                state.selected_index += 1;
            }
        }
        InputEvent::Enter => handle_enter(state, config),
        InputEvent::Back => state.navigate_back(),
        InputEvent::Quit => {
            if matches!(state.current_view, View::Workspaces) {
                state.should_quit = true;
            } else {
                state.navigate_back();
            }
        }
        InputEvent::Refresh => {
            // TODO: Implement refresh
        }
        InputEvent::Action(key) => {
            // TODO: Implement actions (will be done in Stage 4)
            let _ = key;
        }
    }
}

fn get_max_index(state: &AppState, config: &Config) -> usize {
    match &state.current_view {
        View::Workspaces => config.workspace.len(),
        View::Projects { workspace_id } => config
            .workspace
            .get(workspace_id)
            .map(|ws| ws.projects.len())
            .unwrap_or(0),
        View::FileBrowser {
            workspace_id,
            project_index,
        } => {
            let view = FileBrowserView::new(
                config,
                workspace_id,
                *project_index,
                state.selected_index,
            );
            view.visible_count()
        }
    }
}

fn handle_enter(state: &mut AppState, config: &Config) {
    match &state.current_view {
        View::Workspaces => {
            let view = WorkspacesView::new(config, state.selected_index);
            let ids = view.workspace_ids();
            if let Some(id) = ids.get(state.selected_index) {
                state.navigate_to_workspace(id.to_string());
            }
        }
        View::Projects { .. } => {
            state.navigate_to_project(state.selected_index);
        }
        View::FileBrowser {
            workspace_id,
            project_index,
        } => {
            // TODO: Toggle expand or open file (will be done in Stage 4)
            let _ = (workspace_id, project_index);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    use crate::config::{GlobalConfig, Workspace};

    fn create_test_config() -> Config {
        let mut workspaces = HashMap::new();
        workspaces.insert(
            "test".to_string(),
            Workspace {
                name: "Test".to_string(),
                actions: HashMap::new(),
                projects: vec![],
            },
        );

        Config {
            global: GlobalConfig {
                editor: "$EDITOR".to_string(),
                git_info_level: Default::default(),
                actions: HashMap::new(),
            },
            web_client: Default::default(),
            workspace: workspaces,
        }
    }

    #[test]
    fn when_handling_up_input_should_decrease_index() {
        let config = create_test_config();
        let mut state = AppState::new();
        state.selected_index = 1;

        handle_input(&mut state, &config, InputEvent::Up);
        assert_eq!(state.selected_index, 0);
    }

    #[test]
    fn when_handling_up_at_zero_should_stay_at_zero() {
        let config = create_test_config();
        let mut state = AppState::new();
        state.selected_index = 0;

        handle_input(&mut state, &config, InputEvent::Up);
        assert_eq!(state.selected_index, 0);
    }

    #[test]
    fn when_handling_quit_at_workspaces_should_set_should_quit() {
        let config = create_test_config();
        let mut state = AppState::new();

        handle_input(&mut state, &config, InputEvent::Quit);
        assert!(state.should_quit);
    }

    #[test]
    fn when_handling_quit_at_projects_should_navigate_back() {
        let config = create_test_config();
        let mut state = AppState::new();
        state.navigate_to_workspace("test".to_string());

        handle_input(&mut state, &config, InputEvent::Quit);
        assert!(!state.should_quit);
        assert!(matches!(state.current_view, View::Workspaces));
    }
}
```

**Step 2: Run test to verify compilation**

Run: `cargo test tui::runner --no-run 2>&1 | head -30`
Expected: Should compile

**Step 3: Update tui/mod.rs**

```rust
//! TUI components using ratatui.
//!
//! @author waabox(waabox[at]gmail[dot]com)

pub mod app;
pub mod file_tree;
pub mod runner;
pub mod terminal;
pub mod views;

pub use app::{AppState, View};
pub use file_tree::FileTree;
pub use runner::run;
pub use terminal::{init, restore, poll_event, InputEvent, Tui};
```

**Step 4: Update main.rs to use TUI runner**

Modify the `run_panel` function in `src/main.rs`:

```rust
fn run_panel() {
    // Check if running inside Zellij
    if std::env::var("ZELLIJ").is_err() {
        eprintln!(
            "Error: gz-claude panel must be run inside Zellij.\n\
             Run 'gz-claude' without arguments to start Zellij with the proper layout."
        );
        std::process::exit(1);
    }

    // Load configuration
    let config = match Config::load() {
        Ok(config) => config,
        Err(e) => {
            eprintln!("Error loading configuration: {}", e);
            std::process::exit(1);
        }
    };

    // Run TUI
    if let Err(e) = tui::run(&config) {
        eprintln!("Error running TUI: {}", e);
        std::process::exit(1);
    }
}
```

Also add `use crate::tui;` to the imports at the top of main.rs if not present.

**Step 5: Run tests to verify they pass**

Run: `cargo test tui::runner -- --test-threads=1`
Expected: 4 tests passing

**Step 6: Commit**

```bash
git add src/tui/ src/main.rs
git commit -m "feat(tui): add TUI runner with main loop"
```

---

## Task 8: Integration Test for Panel Mode

**Files:**
- Modify: `tests/cli_test.rs`

**Step 1: Add integration test for panel with mock Zellij env**

Add to `tests/cli_test.rs`:

```rust
#[test]
fn when_running_panel_with_valid_config_should_start_tui() {
    // This test verifies panel mode starts with valid config
    // We can't test the actual TUI, but we can test it initializes
    let temp_dir = TempDir::new().unwrap();
    setup_test_config(&temp_dir);

    let mut cmd = Command::cargo_bin("gz-claude").unwrap();
    // Set ZELLIJ env to pretend we're inside Zellij
    // But the TUI will fail to initialize without a real terminal
    // So we just verify it gets past the Zellij check
    cmd.arg("panel")
        .env("HOME", temp_dir.path())
        .env("ZELLIJ", "true")
        .timeout(std::time::Duration::from_millis(500))
        .assert();
    // The process will fail because there's no terminal,
    // but it won't fail with the "must be run inside Zellij" error
}
```

**Step 2: Run the test**

Run: `cargo test cli_test -- --test-threads=1`
Expected: Tests pass (the TUI test may timeout but shouldn't show Zellij error)

**Step 3: Commit**

```bash
git add tests/cli_test.rs
git commit -m "test(cli): add panel mode integration test"
```

---

## Final Verification

After completing all tasks, run:

```bash
cargo fmt --check
cargo clippy -- -D warnings
cargo test
cargo build --release
```

All should pass with no errors or warnings.

---

## Summary

| Task | Component | Tests |
|------|-----------|-------|
| 1 | AppState + View enum | 5 |
| 2 | Terminal setup + events | 7 |
| 3 | WorkspacesView | 3 |
| 4 | ProjectsView | 3 |
| 5 | FileTree model | 4 |
| 6 | FileBrowserView | 2 |
| 7 | TUI Runner | 4 |
| 8 | CLI integration | 1 |

**Total new tests:** ~29
